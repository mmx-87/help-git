# Ветки (Branch)

[Возврат к Оглавлению](./README.md)

### **Содержание**
1. [Что такое ветка](#1-что-такое-ветка)
2. [Зачем нужны ветки](#2-зачем-нужны-ветки)
3. [Создание и переключение](#3-создание-и-переключение)

## 1. Что такое ветка

> **Ветка** - изолированный поток разработки, в котором можно делать комиты так, что их не видно из других веток.


На самом деле как только мы делаем первый комит, GIT создаёт первую ветвь разработки - master.

> **Текущая ветка** - ветвь разработки, в которой мы работаем на данный момент

## 2. Зачем нужны ветки
### 2.1. Тематические ветки
 Когда к нам в голову пришла идея - добавить новую функциональность, но во-первых это требует времени, и во-вторых мы хотели бы работать над новой функциональностью периодически, не смешивая при этом этот экспериметнальный код с основным кодом проекта.
> **Тематическая ветка** - такая ветка, в которой ведется разработка новой функциональности.

### 2.2. Релизы
Еще ветки полезны для одновременной поддержки различных версий проекта - релизов

> **Релиз** - по сути ещё одна ветка, в которую обычно не включают новый функционал, а исправляют ошибки

## 3. Создание и переключение
Для начала экспериметнов создадим репозиторий, добавим в него файл и закоммитим:
```
git init
git add file
git commit -m '...'
```
Когда делаем певрый коммит, то git создаёт ветку по-умолчанию - master

Технически ветка - это ссылка на комит - её можно увидеть в .git/refs/heads/master

Команда просмотра веток:
```
git branch
```
если передать еще парамет -v - покажет идентификатор коммита

В .git есть файл HEAD - он используется для того, чтобы GIT понимал, где именно в репозитории мы находимся - т.е. HEAD хранит ссылку на текущую ветку

Когда происходит коммит,то:
1. GIT сначала смотрить, на что указывает HEAD
2. В новый коммит записывается информация о коммите-родителе, на базе которого и создается новый коммит
3. После того как новый коммит создан ссылка master переключается на него (в файл мастер записывается новый идентификатор коммита)

Представим, будто у нас появилась новая идея. Для реализации этой идеи мы создадим отдельную новую ветку:
```
git branch feature
```
новая ветка создана и указывает на тот же коммит, что и ветка master - это можно увидеть в .git/refs/heads/feature.

Теперь нужно переключиться на новую ветку - для этого нужно обновить HEAD:
```
git checkout feature
```
Если теперь, добавим что-нибудь в код и сделаем коммит, то сдвинется указатель на коммит в файле feature

Теперь, если вернутьтся в master
```
git checkout master
```
эта команда сделает 2 вещи:
1. Изменит ссылку на текущую ветку в HEAD
2. Перенесет в рабочий каталог файлы проекта из ветки master на момент последнего коммита в ветке master

Создадим ветку fix и тут же переключимся на нее
```
git checkout -b fix
```


> cherry-pick - применение коммита из одной ветки к коду в другой ветке



